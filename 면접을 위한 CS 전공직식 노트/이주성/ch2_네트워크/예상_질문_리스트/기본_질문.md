### **HTTP 프로토콜에 대해 설명해주세요.**

HTTP(Hyper Text Transport Protocol) 프로토콜은 웹에서 데이터를 주고받기 위한 프로토콜로, 웹 브라우저와 같은 클라이언트와 서버 간 요청과 응답을 기반으로 동작하는 서버/클라이언트 모델을 따릅니다.

HTTP 프로토콜을 크게 2가지 특징이 있는데요. 먼저 상태를 저장하지 않아 모든 요청을 독립적으로 만드는 무상태 Stateless 특징과 요청에 해당하는 응답을 마친 후 바로 연결을 끊어 연결을 유지하지 않는 비연결성 connectionless 특징이 있습니다. 

이러한 특징으로 인해 통신 간 연결 상태 처리나 상태 정보를 관리할 필요가 없어서 서버의 부담을 줄여줄 수 있습니다. 하지만 클라이언트의 상태가 유지되지 않기 때문에 서버는 요청마다 클라이언트가 누구인지 인증을 받아야 합니다. 이러한 방식은 사용자 경험을 떨어뜨릴 수 있으므로 쿠키, 세션, 토큰과 같은 전략을 사용해 보완해야 합니다.

### **그렇다면 쿠키, 세션의 차이는 뭔가요?**

쿠키와 세션 모두 HTTP의 무상태성 Stateless의 한계를 보완하고자 사용되는 전략입니다. 

쿠키는 사용자의 컴퓨터에 저장하는 작은 기록 정보 파일로 HTTP에서 클라이언트, 즉 접속자의 PC에 상태 정보를 text 형식으로 저장했다가 필요할 때 재사용할 수 있습니다. 다만 쿠키는 당사자 뿐만 아니라 제 3자가 조회하는 것도 가능하기 때문에 XSS(크로스-사이트 스크립팅)과 같은 보안 취약점에 노출될 수 있습니다.

세션은 일정 시간동안 같은 사용자, 즉 같은 브라우저로부터 들어오는 요청을 하나의 상태로 보고 그 상태를 유지시키는 방법입니다. 각 클라이언트에 고유 세션 ID가 부여되며 이 ID는 쿠키를 통해 관리됩니다. 서버 측에서 사용자 정보를 제어할 수 있어서 보안 측면에서는 좋지만 서버 자원을 많이 사용하기 때문에 사용자가 몰리면 속도 저하가 있을 수 있습니다.

### **캐시와의 차이는 뭔가요?**

쿠키, 세션이 사용자의 상태 정보를 저장하는 전략이었다면 캐시는 웹 페이지를 더 빠르게 렌더링하기 위한 전략입니다.

캐시는 이미지, 비디오, 오디오 등의 데이터를 미리 복사한 리소스 파일들의 임시 저장소라고 할 수 있는데요. 여기에 저장된 데이터가 다시 사용될 경우 빠르게 접근할 수 있어서 페이지의 로딩 속도를 향상시킬 수 있습니다. 

### **HTTP와 HTTPS의 차이점에 대해 설명해주세요.**

HTTP와 HTTPS의 주요 차이점은 보안입니다. 

HTTP는 데이터를 암호화하지 않고 전송하기 때문에 도청이나 변조에 취약합니다. 이러한 문제를 해결하기 위해 HTTP에 암호화가 추가된 프로토콜이 HTTPS입니다. HTTP는 TCP와 직접 통신하는 반면, HTTPS는 SSL/TLS를 통해 데이터를 암호화한 후 TCP와 통신해 웹사이트의 신뢰성과 안정성을 보장합니다. 

### [**www.naver.com에](http://www.naver.xn--com-568n/) 접속하는 과정에 대해 설명해주세요**

먼저 사용자가 url을 웹 브라우저에 입력하면 HTTPS와 같은 프로토콜을 통해 DNS 서버에 도메인 네임에 해당하는 IP 주소를 요청하고 응답받은 주소로 TCP 3 way handshake 과정을 통해 웹 서버에 연결합니다. 연결이 완료되면 HTTP 요청 메세지를 전달해 웹 페이지 데이터에 해당하는 HTTP 응답 메세지를 받은 후 웹 페이지로 렌더링해 사용자에게 출력합니다.

### **TCP와 UDP의 차이를 설명해주세요**

TCP는 연결 지향형 프로토콜로 3 way handshake과정을 통해 1:1 연결을 맺은 후 데이터를 안정적으로, 순서대로, 에러 없이 전송하지만 속도가 비교적 느립니다. 

UDP는 비연결형 프로토콜로 데이터 수신 여부를 확인하지 않기 때문에 TCP보다 신뢰성은 떨어지지만 속도가 매우 빠릅니다. 그래서 신뢰성이 중요한 파일 교환과 같은 경우엔 TCP를, 실시간성이 중요한 스트리밍과 같은 경우네는 UDP를 사용합니다.

### **TCP의 통신 방식에 대해 더 자세하게 설명해주세요**

TCP는 3 way-handshake를 통해 연결을 맺고 데이터를 수신한 후 4 way-handshake를 통해 연결을 안정적으로 종료합니다.

3 way-handshake는 총 3단계로 진행되는데요. 먼저 클라이언트가 서버로 연결을 희망한다는 의미의 SYN 패킷을 전송하면 서버는 클라이언트의 연결 요청을 수락한다는 의미로 SYN 패킷에 ACK 패킷을 붙여 전송합니다. 클라이언트는 서버의 응답을 확인하고 ACK 패킷을 다시 보내면서 최종적으로 연결됩니다.

4 way-handshake는 총 4단계로 진행되는데요. 먼저 클라이언트가 서버에 연결을 종료하고 싶다는 의미로 FIN 패킷을 전송하면 서버는 ACK 패킷을 전송한 후 FIN 패킷을 연달아 전송합니다. 클라이언트는 서버의 패킷을 확인하고 다시 ACK 패킷을 보내면서 최종적으로 연결이 해제됩니다.

이런 과정을 통해 TCP는 안정적이고 신뢰성있는 데이터 전송을 보장합니다.

### **OSI 7 Layer와 각 계층에 대해 설명해주세요**

OSI 7 계층은 네트워크 통신을 7개의 계층으로 나누어 설명하는 모델입니다. 클라이언트에서 서버로 데이터를 전송한다고 가정했을 때 상위 계층에서 하위 계층으로 캡슐화 과정을 거칩니다. 

Application 계층에서 HTTP 프로토콜을 사용한 요청 데이터가 생성되고 Presentation 계층에서 요청 데이터가 암호화 및 압축되며 세션 계층에서 웹 서버와의 세션이 설정됩니다. 

이제 Transport 계층에서 HTTP 요청 데이터가 TCP 세그먼트로 분할되며 각 세그먼트는 신뢰성 있는 전송을 위해 순서 번호와 오류 검출 코드를 포함합니다. Network 계층에서 TCP 세그먼트가 IP 패킷으로 캡슐화되며 출발지 및 목적지 IP 주소가 추가됩니다. 

Data Link 계층에서 IP 패킷이 프레임으로 캡슐화되며, 출발지 및 목적지 MAC 주소가 추가되고 오류 검출을 위한 체크섬도 포함됩니다. 마지막 물리 계층에서 프레임이 비트 스트림으로 변환되어 이더넷 케이블과 같은 물리적 장치를 통해 서버의 물리 계층으로 전송합니다.

이렇게 서버측 물리 계층에 전송된 데이터를 상위 계층으로 디캡슐화하면서 최종적으로 HTTP 요청 메세지가 웹 서버에 도착해 처리됩니다.

### **TCP/IP 4계층을 설명해주세요**

OSI 7 계층을 4계층으로 단순화한 모델로 Application 계층, 전송 계층, 인터넷 계층, 네트워크 액세스 계층으로 이루어져 있습니다. OSI 7계층이 데이터 통신에 필요한 계층과 역할을 정확하게 정의하려고 만들어진 모델이라면 TCP/IP 4계층은 현재 인터넷에서 실제 사용되는 프로토콜로 좀 더 실무적이면서 단순화된 모델입니다.

### **HTTP Method에 대해 설명해주세요**

HTTP 메소드는 클라이언트가 서버에 HTTP 요청을 보낼 때 요청의 목적을 알리는 수단입니다. url에 요청 파라미터를 포함해 데이터를 조회하는 GET, 요청 body에 데이터를 포함해 리소스를 생성하거나 업데이트하는 POST, 요청 body에 데이터를 포함해 리소스의 일부 혹은 전체를 수정하는 PATCH 및 PUT, 서버에서 지원하는 HTTP 메서드를 확인해 주로 CORS 사전 요청으로 사용하는 OPTIONS와 같은 것들이 있습니다.

### **GET과 POST의 차이점에 대해 설명해주세요**

GET은 url에 변수를 포함시켜 요청하는 방식으로 url에 데이터가 노출되기 때문에 개인정보와 같은 민감한 정보를 포함하지 않는 경우에 캐싱을 통해 빠른 속도로 데이터를 조회하고자 할 때 사용합니다. 

POST는 데이터를 Body에 담아 요청하기 때문에 비교적 안전하게 데이터 처리를 요청할 수 있습니다.

요청 데이터의 위치 뿐만 아니라 멱등성에서도 차이가 있는데요. GET은 리소스를 조회만 하므로 여러 번 요청하더라도 동일한 응답이 발생하기 때문에 멱등성이 있는 반면, POST는 동일 요청을 여러 번 수행하면 매번 응답이 변경될 수 있으므로 멱등성이 없습니다.

### **세션 기반 인증과 토큰 기반 인증의 차이에 대해 설명해주세요**

세션 기반 인증은 클라이언트로부터 요청을 받으면 클라이언트의 상태 정보를 저장하므로 Stateful한 구조를 가지기 때문에 서버 자원을 많이 사용해서 속도가 느려질 수 있습니다. 또한 세션 ID를 쿠키로 관리하기 때문에 악성 공격자가 쿠키를 훔쳐 요청하는 세션 하이재킹과 같은 공격에 취약합니다.

반면 토큰 기반 인증은 서버가 토큰을 발급하고 클라이언트가 이 토큰을 저장해 요청마다 인증 헤더에 포함시켜 보내는 방식으로 상태를 서버에 저장하지 않고 토큰 자체에 필요한 모든 정보를 포함하기 때문에 Stateless한 구조를 가지므로 토큰을 클라이언트 측에서 관리해 서버 부담을 줄일 수 있습니다.

### **그렇다면 세션 기반 인증과 토큰 기반 인증은 어느 경우에 사용해야 적합한가요?**

세션 기반 인증은 서버의 자원을 사용하기 때문에 성능 이슈로 단일 도메인이 아닌 이상 사용하지 않는 것이 좋습니다. 다만 보안상의 이유로 LinkedIn처럼 사용자의 활동을 서버에서 직접 관리하고 싶은 경우, 혹은 Microsoft처럼 다양한 서비스간 통합된 인증 체계를 제공하기 위해서 사용될 수 있습니다.

토큰 기반 인증은 특히 사용자 인증과 같이 민감한 정보를 처리할 때 적합합니다. JWT와 같은 토큰을 통해 자체적으로 인증 정보를 포함하고 이를 클라이언트에서 관리하도록 해 서버의 부담을 줄일 수 있습니다.

### **JWT 토큰에 대해 설명해주세요**

JWT 토큰은 JSON 포맷을 사용하는 Claim 기반의 웹 토큰으로 토큰 자체를 정보로 사용하는 Self-Contained 방식으로 정보를 안전하게 전달합니다. 

토큰의 타입과 해시 암호화 알고리즘이 명시된 헤더와 JSON 포맷의 Claim 정보인 Payload, 토큰의 서명을 위한 고유 key가 담긴 시그니쳐로 구성되어 있습니다.

실제로 저도 프로젝트에서 사용자 인증을 위해 JWT 토큰을 사용하는데요. JWT 토큰은 클라이언트 측에서 관리되기 때문에 한 번 탈취당하면 토큰의 만료 기한까지 탈취자가 그 토큰의 주인처럼 행동할 수 있고, 특정 사용자의 토큰을 강제로 만료시키기도 어렵다는 단점이 있습니다. 

저는 그래서 토큰의 만료 기한의 최대한 짧게 설정해서 피해를 최소화할 수 있도록 했고, 만료 시 매번 재로그인이 아닌 자동으로 재발급 받을 수 있도록 Refresh Token을 함께 사용했습니다. 또한 이 모든 토큰을 Redis 캐시 서버에서 관리해 빠르게 인증과 재발급이 이루어지도록 했고, 토큰을 사용자당 하나만 유지할 수 있도록 철저하게 관리했습니다.

### **대칭키, 비대칭키 암호화 방식에 대해 설명해주세요.**

대칭키와 비대칭키 모두 양방향 암호화 방식입니다. 

대칭키 암호화는 암호화와 복화화에 같은 암호키를 사용하는 알고리즘으로 빠르고 효율적이지만 키가 탈취된 순감 정보가 전부 유출되기 때문에 보안성이 떨어집니다.

이러한 문제를 보완한 방식이 비대칭키 암호화 방식인데요. 암호화와 복호화를 할 때 서로 다른 키를 사용하는 알고리즘으로 누구나 접근할 수 있는 공개키로 데이터를 암호화하고, 오직 개인키를 통해서만 복호화할 수 있는 방법입니다. 

따라서 대칭키 암호화는 주로 대량의 데이터를 빠르게 암호화할 때 적합하고, 비대칭키 암호화는 디지털 서명, 인증 등의 민감한 데이터의 암호화를 목적으로 사용됩니다.

### **Connection Timeout과 Read Timeout의 차이에 대해 설명해주세요**

Connection Timeout은 클라이언트가 서버에 접속을 시도할 때 서버에 연결하기까지의 설정한 시간이 지나도 연결이 안될 경우 발생합니다. 주로 서버가 다운되었거나 네트워크 문제로 서버에 도달하지 못했을 때 발생합니다.

Read Timeout은 클라이언트가 서버에 접속을 성공한 후 서버가 요청을 처리하고 응답을 반환하는데 걸리는 시간이 설정된 시간이 지나도 응답을 받지 못한 경우 발생합니다. 이 때 클라이언트는 연결을 해제하는 등의 대처를 하지만 서버는 여전히 처리중이라서 상태 불일치 문제가 발생할 수 있습니다.

### **그렇다면 그 상태 불일치 문제는 어떻게 해결하나요?**

타임아웃이 발생했을 시 요청을 다시 시도하는 재시도 로직을 구현하고, 지수 백오프를 통해 재시도 간격을 점차 늘려가서 서버의 과부하를 방지하면서 계속 재시도할 수 있도록 할 수 있습니다.

아니면 클라이언와 서버가 요청의 상태를 주기적으로 확인하고 동기화하도록 별도의 API를 사용하는 방법도 있을 것 같구요.

아예 작업 대기열 큐를 통해 요청을 대기열에 넣고 서버가 비동기적으로 처리한 후 클라이언트에게 알림을 보내는 방식으로 동기화 문제를 해결할 수도 있을 것 같습니다.

### **공인 IP와 사설 IP의 차이에 대해 설명해주세요**

공인 IP는 ISP(Internet Service Provider)가 제공하는 고유한 IP 주소로, 외부에 공개되어 있는 IP 주소입니다. 따라서 인터넷 상의 모든 장치가 이 주소를 통해 인터넷에 연결할 수 있습니다.

사설 IP는 가정이나 회사 내에 할당된 네트워크 IP 주소로, IPv4의 주소 부족 문제를 해결하기 위해 서브넷팅된 IP 주소입니다. 라우터 공유기에 의해 로컬 네트워크 상의 PC나 장치에 할당되고, 내부 네트워크에서만 사용되기 때문에 인터넷 상에서는 직접 사용할 수 없습니다.

사설 IP 주소만으로는 인터넷에 직접 연결할 수 없고, 라우터를 통해 공인 IP를 할당받아 외부와 통신할 수 있습니다. 이를 통해 하나의 공인 IP 주소로 사설 IP 주소가 할당된 여러 장치가 인터넷에 연결될 수 있습니다.
