
## 프로세스와 스레드

**프로세스**
- 프로세스는 프로그램의 실제 실행 
- 프로그램 파일을 실행함으로써 프로그램 데이터들이 메모리에 올라와 CPU를 할당받고 명령을 수행하고 있는 상태
- 프로세스는 운영체제로부터 자원을 할당받은 최소 작업 단위이며 완벽히 독립적이기 때문에 메모리 영역을 다른 프로세스와 공유하지 않는다.
- 여러 개의 자식 프로세스 중에 하나에 문제가 발생하면 자식 프로세스만 죽고 다른 프로세스에는 영향을 미치지 않기 때문에 프로그램 전체의 안정성을 확보할 수 있다.
- 프로세스 간 컨텍스트 스위칭과 통신의 비용이 크다는 단점

**스레드**
- 프로세스가 운영체제로부터 할당받은 자원을 이용하는 실행 단위
- 하나의 프로세스는 반드시 하나 이상의 스레드 보유 
- 프로세스 내에서 Stack만 할당받고 나머지 메모리 영역을 공유하기 때문에 다른 스레드의 실행 결과를 즉시 확인 가능
- 공유하는 메모리 영역이 존재하기 때문에 동기화 문제가 발생할 수 있으므로 대처 필요
- 프로세스와 다르게 하나의 스레드에 문제가 발생하면 전체 프로세스에 영향을 미침 
- 스레드 간 컨텍스트 스위칭과 통신 비용이 적다는 장점

<br/>

---

### 프로세스와 컴파일 과정

![img_10.png](img_10.png)

- 컴파일러가 C 코드를 MIPS(어셈블리어)로 바이너리화(컴파일) 해주면 어셈블리어가 변환을 해줄 것이다.
- 변환 과정이 매우 중요하다. → Linking
    - 여러 모듈로 분리된 프로그램의 코드와 데이터를 하나로 연결하여 실행 가능한 단일 파일을 생성하는 과정
    - 어셈블리어 코드를 합쳐두고그때  이들 간의 상대적인 위치를 계산하여 절대 주소로 변환합니다.
- Linking 단계에서 어셈블리어 코드를 합쳐두고 offset을 계산해서 연산하는 것
    - 다 합쳤을 때 위치를 알 수 있음

**Producing an Object Module**

- Assembler (or compiler) translates program into machine instructions
- 객체 모듈의 구성 요소
    - Header
        - 객체 모듈의 내용 설명
    - Text segment
        - translated instructions
        - 번역된 기게어 명령어
        - instruction들이 있는 영역
    - Static data segment
        - data allocated for the life of the program
        - global variable들이 존재
    - Relocation info
        - relocation은 프로그램이 항상 동일한 메모리 스페이스에 위치하는 것이 아니기 때문에 그 위치에 대해 내부 프로그램의 로직들을 재조정할 수 있는 정보를 가지고 있음
    - Symbol table
        - 전역 정의 및 외부 참조 포함
        - 레이블을 사용할 때 기계어로 바뀌면 다 offset으로 바뀌기 때문에 그런 정보들을 symbol table에 가지고 있다.
    - Debug info
        - 소스 코드의 디버그 정보

**Linking Object Modules**

- Linking은 여러 개의 객체 파일(Object Module)을 결합하여 실행 가능한 프로그램을 만드는 과정이다. (.exe 또는 .out)
- 컴파일러나 어셈블러가 생성한 객체 파일을 연결하여, 프로그램 내에서 정의된 함수 및 변수들이 서로 참조할 수 있도록 한다.

Linking 과정:
1. 코드 블록 합치기
    - 각각의 객체 파일에 포함된 코드와 데이터를 하나로 결합한다. 이 과정에서 여러 모듈에서 정의된 함수와 변수들이 연결된다.
2. 레이블 위치 판단 및 offset 매칭
    - 결합된 코드에서 레이블(함수, 변수 등)의 정확한 위치를 판단한다. 
    - 각 레이블의 상대적 위치를 기준으로 offset을 계산하고, 이를 바탕으로 실제 메모리 주소에 매핑한다.


**Loading a Program**

1. 헤더 읽기 및 세그먼트 크기 결정
   - 프로그램의 헤더를 읽어, 각 세그먼트(Text, Data 등)의 크기를 결정한다.

2. 가상 주소 공간 생성 
   - 프로그램을 로딩할 가상 주소 공간을 생성하여, 각 세그먼트가 가상 메모리의 어느 위치에 로드될지 결정한다. 
   - Text와 초기화된 데이터 복사:

3. Text 세그먼트(명령어)와 초기화된 데이터 세그먼트를 메모리로 복사한다.
   - 혹은 페이지 테이블 항목을 설정하여 필요할 때 페이지 폴트를 통해 메모리로 로드할 수 있도록 한다.

4. 스택에 인수 설정
   - 프로그램 실행에 필요한 인수들을 스택에 설정한다.
   
5. 레지스터 초기화
   - 스택 포인터($sp), 프레임 포인터($fp), 전역 포인터($gp) 등을 초기화하여 프로그램이 실행될 준비를 한다.

6. 시작 루틴으로 점프
   - 초기화가 완료되면 프로그램의 시작 루틴(보통 main 함수)으로 점프하여 프로그램 실행을 시작한다.
   - main 함수가 끝나면 종료 시스템 호출(exit syscall)을 통해 프로그램 실행이 종료된다.

**Dynamic Linking**

동적 링킹은 프로그램 실행 중에 필요한 라이브러리를 메모리에 로드하고 링크하는 과정이다.
정적 링킹과 달리, 프로그램 실행 시점에 필요한 라이브러리 코드만 메모리에 로드되므로 메모리 사용량을 줄일 수 있다.

- 동적 링킹 과정
  1. 가상의 위치 설정
     - 프로그램 내에서 사용하는 외부 라이브러리 함수들을 호출할 가상의 위치를 설정한다.

  2. 라이브러리 함수 호출
     - 해당 함수가 위치한 라이브러리로 이동해 실행한 후 다시 프로그램으로 돌아온다.

- 동적 링킹의 장점
  - 라이브러리의 최신 버전을 자동으로 사용할 수 있다. 
  - 프로그램 이미지의 크기(image bloat)를 줄일 수 있다. 
  - 라이브러리 코드가 재배치 가능하므로, 다른 메모리 위치에서도 올바르게 동작할 수 있다.


<br/>

---

### 프로세스의 상태

![img_11.png](img_11.png)

- New
  - fork() 또는 exec() 함수를 통해 생성
    - fork(): 부모 프로세스의 주소 공간을 그대로 복사해 새로운 자식 프로세스를 생성하는 함수
    - exec(): 새롭게 프로세스를 생성하는 함수
  - 프로세스를 생성하고 있는 단계로 커널 영역에 PCB가 만들어진 상태
- Ready
  - 메모리 공간이 충분하면 메모리를 할당받고 아니면 그대로 대기
  - 프로세스가 CPU 스케줄러로부터 CPU를 할당받기 위해 기다리고 있는 상태
- Runnig
  - 프로세스가 CPU와 메모리를 할당받아 명령어를 실행 중인 상태
  - CPU burst가 일어났다고 표현
- Waiting
  - 프로세스가 I/O 작업 완료 혹은 이벤트를 기다리는 상태
- Terminated
  - 프로세스가 종료된 상태
  - 메모리와 CPU 소유권을 모두 해제


<br/>

---

### 프로세스의 메모리 구조

![img_13.png](img_13.png)

**Stack**

- 함수 안에서 선언된 지역변수, 매개변수, 리턴값 등
- 함수의 호출과 함께 할당되며 함수의 호출이 완료되면 소멸
- 재귀 함수의 경우 새로운 스택 프레임이 매번 사용되기 때문에 함수 내의 변수 집합이 다른 해당 함수의 다른 인스턴스 변수를 방해하지 않는다.

**Heap**

- 사용자에 의해 메모리 공간이 동적으로 할당되고 해제
- 메모리의 낮은 주소에서 높은 주소의 방향으로 할당

**Data**

- BSS segment: 코드가 실행되면서 사용하는 전역변수 static 변수 등 초기화되지 않은 변수 
- Data segment: 코드가 실행되면서 사용하는 전역변수 static 변수 등 0 이 아닌 값으로 초기화된 변수 
- 프로그램의 시작과 함께 할당되며 프로그램이 종료되면 소멸

**Code**

- 사용자가 작성한 프로그램 함수들의 코드
- CPU는 코드 영역에 저장된 명령어를 하나씩 처리

<br/>

---

### 컨텍스트 스위칭

**Context**
프로세스 간 전환을 위해 어디까지 명령을 수행했고, 레지스터에 어떤 값들이 저장되어 있는지 등 정보들이 필요한데 이 정보를 Context라고 하며, Context는 운영체제가 관리하는 PCB 자료 구조에 저장된다.

**PCB(Process Control Block)**

운영체제가 시스템 내의 프로세스들을 관리하기 위해 프로세스마다 유지하는 정보를 담는 커널 내의 자료구조이다. 컨텍스트 스위칭이 바로 프로세스 간 PCB 정보를 교체하고 캐시를 비우는 과정인 것이다.

![img_14.png](img_14.png)


**Context Switching**

하나의 CPU는 하나의 작업만 수행할 수 있기 때문에 여러 프로세스를 동시성으로 처리하기 위해서는 프로세스 간 전환, 즉 프로세스 간 PCB 정보를 교체하고 캐시를 비우는 Context Switching 작업이 필요하다. 

**컨텍스트 스위칭 발생 조건**

1. 실행중인 프로세스에서 I/O 호출이 일어나 상태가 running에서 wating이 된 경우
2. 운영체제의 CPU 스케줄러 알고리즘에 의해 현재 프로세스가 사용할 수 있는 시간 자원을 모두 사용했을 때

![img_15.png](img_15.png)

**유휴 시간(idle)**

- PCB 저장 및 로드하는 과정에서 유휴 시간 발생
- 프로세스의 메모리 주소가 없을 경우 캐시 클리어 과정을 겪게 되는데 이 때 캐시 미스가 발생하면서 유휴 시간 발생

> 스레드도 마찬가지로 컨텍스트 스위칭이 일어나는데 스레드는 프로세스 내 메모리르 ㄹ공유하기 때문에 메모리 주소 관련 추가 작업이 없어 오버헤드가 작아 컨텍스트 스위칭이 빠르다. 

<br/>

---

### 멀티프로세싱

![img_16.png](img_16.png)

여러 프로세스들을 멀티 프로세싱을 통해 동시에 여러 작업을 수행할 수 있도록 한다. 하나 이상의 일을 병렬로 처리할 수 있으며 특정 프로세스에 문제가 발생하더라도 다른 프로세스를 이용해 처리할 수 있어 신뢰성이 높다. 

### 웹 브라우저

웹 브라우저 또한 멀티 프로세스 구조를 가지고 있다.
- 브라우저 프로세스
  - 주소 표시줄, 북마크 막대, 뒤로 가기 버튼, 앞으로 가기 버튼 등 담당
  - 네트워크 요청이나 파일 접근 권한 담당
- 렌더러 프로세스
  - 웹 사이트가 '보이는' 부분의 모든 것을 제어
- 플러그인 프로세스
  - 웹 사이트에서 사용하는 플러그인 제어
- GPU 프로세스
  - GPU를 이용해 화면을 그리는 부분 제어

### IPC(Inter Process Communication)

멀티 프로세스는 프로세스끼리 데이터를 주고 받고 공유 데이터를 관리하는 IPC가 가능하다.
- 클라이언트가 데이터를 요청하고 서버는 클라이언트 요청에 응답하는 것도 IPC의 일종

**공유 메모리**

![img_17.png](img_17.png)

- 여러 프로세스들이 메모리 공간을 공유해서 자신의 메모리처럼 사용
- 빠르고 효율적이지만 동기화 문제가 발생할 수 있기 때문에 접근 제어가 필요하다.

**파일**

- 디스크에 저장된 데이터 또는 파일 서버에서 제공한 데이터를 기반으로 IPC

**익명 파이프(unnamed pipe)**

![img_18.png](img_18.png)

- 프로세스 간 FIFO 방식으로 읽히는 임시 공간인 파이프를 기반으로 통신
- 단방향 방식의 읽기 전용, 쓰기 전용 파이프를 만들어서 작동
- 부모, 자식 프로세스 간에만 사용 가능

**네임프 파이프(named pipe)**

![img_19.png](img_19.png)

- 파이프 서버와 하나 이상의 파이프 클라이언트 간의 통신을 위한 단방향 또는 양방향 파이프
- 클라이언트/서버 통신을 위한 별도의 파이프 제공
- 여러 파이프 동시 사용 가능
- 프로세스끼리 혹은 다른 네트워크 사의 컴퓨터와도 통신 가능


**메세지 큐**

- 메세지를 큐 데이터 구조 형태로 커널에서 전역적으로 관리
- 직관적이고 간단하게 구현
- 공유 메모리를 통해 IPC를 구현할 때 쓰기 및 읽기 빈도가 높으면 동기화 때문에 복잡해지는데 대안으로 메세지 큐를 사용하기도 한다.


<br/>

---

### 스레드

![img_20.png](img_20.png)

스레드는 프로세스가 OS로부터 할당 받은 자원을 이용하는 CPU의 최소 실행 단위로 프로세스는 여러 스레드를 가질 수 있으며 반드시 하나 이상의 스레드를 가진다. 
프로세스 내에서 Code, Data, Heap 영역은 공유하고, Stack만 각자 할당받는다. 따라서 스레드 간 메모리 스택 영역은 접근할 수 없기 때문에 독립적인 함수 호출이 가능해진다.

### 멀티스레딩

![img_21.png](img_21.png)

- 프로세스 내 작업을 여러 개의 스레드로 동시적 & 병렬적으로 처리하는 기법
- 스레드끼리 서로 자원을 공유하기 때문에 효율성은 좋지만 동시성 문제가 발생할 수 있음


<br/>

---

### 공유 자원

- 프로세스, 스레드가 함께 접근할 수 있는 모니터, 프린터, 메모리, 파일 등의 자원
- 공유 자원을 2개 이상의 프로세스가 읽거나 쓰면 경쟁 상태(race condition) 발생

### 임계 영역(critical section)
- 둘 이상의 스레드가 동시에 접근해서는 안되는 공유 자원 영역으로 이 영역에 여러 스레드가 접근하게 되면 race condition이 발생하면서 예상치 못한 결과 발생
- 하나의 프로세스만 진입할 수 있도록 보장하기 위해 3가지 충족 조건이 필요


1. Mutual Exclusion(상호 배제): 임계 영역에 진입한 스레드가 존재한다면 다른 스레드는 접근할 수 없다.
2. Progress(융통성): 임계 영역에 진입한 스레드가 없고 임계 영역에 진입하려는 스레드만 있을 때 어떤 스레드가 들어갈 것인이 적절한 선택을 빠르게 진행
3. Bounded Waiting(한정 대기): 기아 상태가 발생하지 않도록 임계 영역에 들어간 스레드에 대한 제한 필요


### Mutex

- Mutual Exclution(상호 배제)를 구현하기 위한 동기화 도구
- 공유 자원에 대한 race Condition을 방지하고 동시성 제어를 위한 락 메커니즘
- 스레드가 뮤텍스 락을 보유하면 해당 임계 영역에 진입하려는 모든 스레드가 차단되며 락을 보유한 스레드가 락을 해제할 때까지 차단된다.

### Semaphore

- 공유 자원에 대한 접근을 제어하기 위해 사용되는 신호전달 메커니즘으로 공유 자원에 지정된 스레드 수만 접근할 수 있도록 관리
- 이미 허용된 최대 스레드 수에 도달해 임계영역에 진입하지 못할 경우 자발적으로 wait() 대기 상태에 들어가고, 임계 영역을 빠져나오는 스레드가 대기 상태의 스레드를 실행 대기 상태로 signal() 깨워주는 방식으로 동기화 구현

**바이너리 세마포어**

- 0과 1 두 가지 값만 가질 수 있는 세마포어
- 뮤텍스와 유사

**카운팅 세마포어**

- 여러 값을 가질 수 있는 세마포어
- 여러 자원에 대한 접근 제어

### Monitor

- 여러 프로세스나 스레드가 공유 자원에 안전하게 접근할 수 있도록 공유 자원을 숨기고 해당 접근에 대해 인터페이스 제공
- 모니터 큐를 통해 공유 자원에 대한 작업들을 순차적으로 처리
- Mutual Exclusion
  - 객체의 모니터락을 통해 여러 스레드가 동시에 공유 자원에 접근하지 못하도록 제어
- Cooperation
  - 모니터의 조건 변수를 통해 스레드 간의 협력을 관리해 데이터 일관성 보장

<br/>

---

### 교착 상태(deadlock)

- 프로세스나 스레드들이 서로가 소유하고 있는 락을 기다리면서 무한히 대기하고 있는 상태로 4가지 조건을 동시에 만족할 때 발생

1. 상호 배제
   - 임계 영역에 한 번에 하나의 스레드만 진입 가능 
2. Hold and Wait(점유 대기)
   - 스레드가 공유 자원을 보유한 상태에서 다른 자원을 기다림 
3. No Preemption(비선점)
   - 자원을 할당받은 스레드가 자원을 스스로 반납하기 전까지 자원을 강제로 뺐을 수 없음 
4. Curcular Wait(순환 대기)
   - 각 스레드가 순환적으로 다음 스레드가 요구하는 자원을 가지고 있어서 사이클이 형성

**데드락 해결법**

데드락이 이미 발생하면 애플리케이션 단에서 데드락을 해소하기는 어렵기 때문에 서버를 재 기동하거나 종료하는 것 밖에 현실적으로 해결책이 없다.

1. 데드락은 스레드가 락을 중첩으로 제어하면서 발생하는 경우가 많기 때문에 가능한 한 한번에 하나 이상의 락을 사용하지 않도록 하자
2. 어쩔 수 없이 여러 개의 락을 사용해야 할 경우 순환 대기가 발생하지 않도록 락의 순서를 잘 조정하자
3. 일정 시간 내에 락을 얻지 못하면 무한 대기하는 것이 아닌 락 타임 아웃을 걸어 다른 작업을 수행하도록 하자
4. 락이 없는 상태에서 메서드를 호출할 수 있도록 오픈 호출 형태로 메서드를 구현해 락은 정말 필요한 임계 영역만 보호하도록 하자 
5. 스레드 덤프를 사용해 스데르의 스택 트자이스 및 락 정보를 통해 어떤 스레드에 언제 왜 데드락이 발생했는지 추적해보


<br/>

