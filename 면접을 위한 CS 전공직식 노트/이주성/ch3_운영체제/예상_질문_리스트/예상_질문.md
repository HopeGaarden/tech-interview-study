### 프로세스와 쓰레드의 차이에 대해 설명해주세요

프로세스는 프로그램의 실제 실행을 의미하며 프로그램 파일을 실행함으로써 프로그램 데이터들이 메모리에 올라와 CPU를 할당받고 명령을 수행하고 있는 상태입니다. 프로세스는 운영체제로부터 자원을 할당받은 최소 작업 단위이며 완벽히 독립적이기 때문에 메모리 영역을 다른 프로세스와 공유하지 않습니다.

또한 여러 개의 자식 프로세스 중에 하나에 문제가 발생하면 자식 프로세스만 죽고 다른 프로세스에는 영향을 미치지 않기 때문에 프로그램 전체의 안정성을 확보할 수 있지만 프로세스 간 컨텍스트 스위칭과 통신의 비용이 크다는 단점이 있습니다.

스레드는 프로세스가 운영체제로부터 할당받은 자원을 이용하는 실행 단위로 하나의 프로세스는 반드시 하나 이상의 스레드를 갖습니다. 스레드는 프로세스 내에서 Stack만 할당받고 나머지 메모리 영역을 공유하기 때문에 다른 스레드의 실행 결과를 즉시 확인할 수 있습니다. 공유하는 메모리 영역이 존재하기 때문에 동기화 문제가 발생할 수 있으므로 적절한 대처가 필요합니다.

또한 프로세스와 다르게 하나의 스레드에 문제가 발생하면 전체 프로세스에 영향을 미치지만 스레드 간 컨텍스트 스위칭과 통신 비용이 적다는 장점이 있습니다.

### 멀티 쓰레드의 동시성과 병렬성을 설명해주세요

동시성은 CPU가 한 번에 많은 일을 처리하기 위해 여러 작업을 여러 스레드가 빠른 시간 안에 교체하면서 전체 작업을 처리하는 것을 의미합니다. 단일 코어에서도 마치 여러 작업이 동시에 진행되는 것처럼 보이게 하기 때문에 여러 작업이 동시에 수행되는 것 같은 효과를 얻을 수 있습니다.

병렬성은 멀티 코어 환경에서 CPU가 놀지 않고 최대한 사용될 수 있도록 각 코어들을 동시에 물리적으로 실행하는 것을 의미합니다. 작업을 여러 스레드로 분리하고 운영체제를 통해 그 스레드를 여러 CPU에 적절히 분배해 동시에 작업을 처리해 처리 속도를 높일 수 있습니다.

동시성과 병렬성은 서로 배타적인 개념이 아니라 조합하면 애플리케이션의 성능을 극대화할 수 있는데요. 예를 들어 자바의 ThreadPoolExecutor를 사용해 제한된 수의 스레드를 재사용해 동시성을 관리하고 ForkJoinPool을 이용해 작업을 작은 단위로 분할해 병렬로 처리할 수 있도록 해줄 수 있습니다.

### 컨텍스트 스위칭이 무엇인지 설명해주세요

컨텍스트 스위칭은 하나의 CPU가 동일한 시간에 하나의 작업만 수행할 수 있기 때문에 여러 프로세스를 동시에 실행할 수 없어서, 빠른 시간 안에 여러 프로세스를 전환하는 과정을 말합니다. 즉, CPU가 하나의 프로세스를 실행하다가 다른 프로세스를 실행하기 위해 현재 작업의 상태를 저장하고 새로운 작업의 상태를 불러오는 과정을 뜻합니다.

컨텍스트 스위칭은 프로세스 혹은 스레드 간에 일어날 수 있습니다. 프로세스를 기준으로 설명하자면, 각 프로세스는 커널 내에 프로세스 정보들이 담긴 Process Control Block (PCB) 컨텍스트를 갖고 있습니다. CPU가 프로세스 간에 전환될 때, 현재 프로세스의 PCB 정보를 저장하고 다음 프로세스의 PCB 정보를 불러오는 과정과 CPU 캐시를 비우고 새로운 프로세스의 데이터를 로드하는 등의 과정이 일어납니다.

컨텍스트 스위칭은 2가지 조건으로 발생되는데요. 실행중인 프로세스에서 I/O 작업이 일어나서 해당 작업이 끝날 때까지 프로세스 상태가 running에서 waiting 상태로 전이된 경우와 운영체제의 CPU 스케줄러 알고리즘에 의해 현재 실행중인 프로세스가 시간 자원을 모두 사용해서 프로세스가 ready 상태로 전이된 경우에 컨텍스트 스위칭이 발생합니다.

### CPU Bound와 I/O Bound의 차이에 대해 설명해주세요 \*\*\*\*\*

프로세스는 CPU 명령을 수행하다가 I/O 작업을 만나면 대기하고, I/O 작업이 완료되면 다시 CPU 작업을 수행하는 과정을 반복합니다. 프로세스마다 CPU 버스트와 I/O 버스트가 차지하는 비율을 기준으로 바운드를 나눌 수 있습니다.

CPU Bound는 CPU 버스트 작업이 많은 머신러닝, 블록체인 등 CPU 연산 위주의 작업을 하는 경우에 해당합니다. 멀티 코어의 병렬성을 최대한 활용해서 처리 성능을 극대화하도록 스레드를 운영해야 하는데요. 일반적으로 CPU 코어수와 스레드 수의 비율을 비슷하게 설정해 각 코어가 최대한의 성능을 발휘할 수 있도록 합니다.

I/O Bound는 I/O 버스트 작업이 빈번히 발생하며 CPU 버스트가 매우 짧은 구간으로 파일, 키보드 등 외부 연결이나 입출력 장치와의 통신 작업이 많은 경우에 해당합니다. CPU 코어가 많을 경우 멀티 스레드의 동시성을 최대한 활용해 CPU가 Idle(대기) 상태가 되지 않도록 하고 최적화된 스레드 수를 운영해 CPU의 효율성을 극대화해야 합니다.

### 사용자 모드와 커널 모드의 차이에 대해 설명해주세요 \*\*\*\*\*

운영체제는 사용자가 프로그램을 편하고 효율적으로 사용할 수 있도록 하드웨어와 소프트웨어 간 중재자 역할을 하는데요. 프로그램이 하드웨어 자원에 직접 접근하게 되면 자원 관리가 되지 않고 데이터가 훼손되어 큰 오류를 발생시킬 수 있기 때문에 반드시 운영체제를 통해서만 접근하도록 합니다.

이 때 핵심 기능을 담당하는 부분이 커널입니다. 따라서 CPU는 명령어를 실행할 때 이 커널을 다룰 수 있는 커널 모드와 사용자 모드로 구분해야 실행합니다.

사용자 모드는 프로그램의 코드가 실행되는 모드로 메모리의 유저 영역만 접근이 가능하며 CPU, 메모리, I/O 장치에 접근할 수 없습니다. 하지만 대부분의 프로그램은 입출력 장치나 파일로의 접근이 필요하기 때문에 커널 모드로의 전환이 필요한데요. 이 때 시스템 콜을 통해 사용자 모드와 커널 모드를 전환하면서 명령을 실행하게 됩니다.

### Critical Section(임계영역)에 대해 설명해주세요

Critical Section은 둘 이상의 스레드가 동시에 접근해서는 안되는 공유 자원 영역을 뜻합니다. 이 임계 영역에 여러 스레드가 접근하게 되면 race condition이 발생하면서 예상치 못한 결과를 초래할 수 있습니다. 따라서 이 임계 영역에 하나의 프로세스만 진입할 수 있도록 보장하기 위해 3가지 충족 조건이 필요합니다.

먼저 이미 임계 영역에 진입한 스레드가 존재한다면 다른 스레드는 접근할 수 없는 Mutual Exclusion(상호 배제)을 지켜야 합니다. 또한 임계 영역에 진입한 스레드가 없고 임계 영역에 진입하려는 스레드만 있을 때 어떤 스레드가 들어갈 것인이 적절한 선택을 빠르게 Progress 진행해줘야 하고, 기아 상태가 발생하지 않도록 임계 영역에 들어간 스레드에 제한을 걸어주는 Bounded Waiting이 필요합니다.

이렇게 3가지 조건을 지키기 위해 뮤텍스, 세마포어, 모니터와 같은 여러 동기화 도구들이 존재하는데요. 자바에서는 특히 synchronized 키워드를 통해 임계 영역을 설정하고 스레드 간의 동기화를 구현할 수 있습니다.

### 기아 상태에 대해 설명해주세요 \*\*\*\*\*

멀티스레드 환경에서 한 스레드가 자원을 계속해서 얻지 못하고 영원히 대기하는 상태를 말합니다. 이는 자원이 특정 스레드에만 집중되거나 우선순위가 낮은 스레드가 자주 자원을 할당받지 못할 때 발생합니다. 따라서 우선순위를 기반으로 한 스케줄링이 아닌 모든 스레드가 공평하게 실행될 수 있도록 우선순위가 조정될 수 있도록 운영체제의 스케줄러가 설계되어 있습니다.

### 자바에서 스레드에 안전한 구조를 만들기 위해서는 어떻게 해야하나요? \*\*\*\*\*

자바에서 스레드에 안전한 구조를 만들기 위해서는 먼저 임계 영역에 동시에 여러 개의 스레드가 접근하지 못하도록 락을 통해 동기화 시켜야 합니다. 이를 위해 세마포어, CAS(Compare And Swap), Atomic 변수 등 다양한 동기화 도구들을 사용할 수 있습니다.

세마포어는 공유 자원에 대한 접근을 제한하여 동시 접근을 방지하고, CAS는 변수를 갱신할 때 현재 값이 예상한 값과 일치하는지 확인하여 안전하게 값을 갱신합니다. Atomic 변수는 내부적으로 CAS를 사용하여 스레드 안전한 연산을 제공합니다.

또한, 스레드마다 할당된 스택 메모리 내에서 상태를 관리함으로써 다른 스레드와 상태를 공유하지 않도록 해야 합니다. 이와 함께 전용 저장소인 ThreadLocal을 사용하여 각 스레드가 독립적인 변수를 가질 수 있도록 하면 스레드 간 간섭을 방지할 수 있습니다.

마지막으로, 불변 객체를 사용해 스레드 안전성을 높일 수 있습니다. 불변 객체는 생성 이후 상태가 변경되지 않기 때문에 여러 스레드에서 동시에 읽기 작업을 수행해도 안전합니다.

### 뮤텍스에 대해 설명해주세요 \*\*\*\*\*

뮤텍스는 Mutual Exclution(상호 배제)를 구현하기 위한 동기화 도구로 공유 자원에 대한 race Condition을 방지하고 동시성 제어를 위한 락 메커니즘입니다. 스레드가 이 뮤텍스 락을 보유하면 해당 임계 영역에 진입하려는 모든 스레드가 차단되며 락을 보유한 스레드가 락을 해제할 때까지 차단됩니다.

뮤텍스는 두 개 이상의 스레드가 서로가 가진 락을 기다리면서 상호적으로 블로킹되어서 아무 작업도 수행할 수 없는 상태인 데드락에 빠질 수 있습니다. 또한 높은 우선 순위를 가진 스레드가 낮은 우선 순위를 가진 스레드가 보유한 락을 기다리는 동안 블록되어 작업이 지연되는 우선 순위 역전의 문제가 발생할 수 있습니다. 이 외에도 락을 얻기 위한 스케줄링으로 인한 오버헤드, 성능 저하가 있을 수 있기 때문에 적절한 사용이 필요합니다.

### 데드락에 대해 설명해주세요

데드락이란 프로세스나 스레드들이 서로가 소유하고 있는 락을 기다리면서 무한히 대기하고 있는 상태로 4가지 조건을 동시에 만족할 때 발생합니다.

임계 영역에 한 번에 하나의 스레드만 진입할 수 있는 상호 배제, 스레드가 공유 자원을 보유한 상태에서 다른 자원을 기다리는 Hold and Wait(점유 대기), 자원을 할당받은 스레드가 자원을 스스로 반납하기 전까지 자원을 강제로 뺐을 수 없는 No Preemption(비선점), 각 스레드가 순환적으로 다음 스레드가 요구하는 자원을 가지고 있어서 사이클이 형성되어 버리는 Curcular Wait(순환 대기) 이렇게 4가지 조건이 모두 만족했을 때 발생합니다.

### 그렇다면 데드락을 해결하는 방법이 뭐가 있을까요? \*\*\*\*\*

데드락이 이미 발생하면 애플리케이션 단에서 데드락을 해소하기는 어렵기 때문에 서버를 재 기동하거나 종료하는 것 밖에 현실적으로 해결책이 없습니다.

따라서 데드락이 발생하지 않도록 미리 방지하는 것이 중요한데요. 데드락 발생 조건 4가지 중 최소한 1가지 이상을 만족하지 않도록 하면 데드락을 방지할 수 있습니다.

5가지 정도의 방법이 있는데요. 첫 번째로 데드락은 스레드가 락을 중첩으로 제어하면서 발생하는 경우가 많기 때문에 가능한 한 한번에 하나 이상의 락을 사용하지 않도록 해야합니다. 두 번째는 어쩔 수 없이 여러 개의 락을 사용해야 할 경우 순환 대기가 발생하지 않도록 락의 순서를 잘 조정하는 방법입니다. 세 번째는 일정 시간 내에 락을 얻지 못하면 무한 대기하는 것이 아닌 락 타임 아웃을 걸어 다른 작업을 수행하도록 하는 방법입니다. 네 번째는 락이 없는 상태에서 메서드를 호출할 수 있도록 오픈 호출 형태로 메서드를 구현해 락은 정말 필요한 임계 영역만 보호하도록 하는 방법입니다. 다섯 번째는 스레드 덤프를 사용해 스데르의 스택 트레이스 및 락 정보를 통해 어떤 스레드에 언제 왜 데드락이 발생했는지 추적하는 방법이 있습니다.

### 우선 순위 역전의 문제는 어떻게 해결하죠? \*\*\*\*\*

우선 순위 역전의 문제를 해결하기 위한 방법으로 우선 순위 상속 (Priority Inheritance)이 있습니다. 낮은 우선순위의 스레드가 높은 우선순위의 스레드가 필요로 하는 락을 보유하고 있을 때, 낮은 우선순위의 스레드의 우선순위를 일시적으로 높여서 락을 빨리 해제하도록 합니다. 이를 통해 높은 우선순위의 스레드가 불필요하게 오래 대기하지 않도록 할 수 있습니다.

### 세마포어에 대해 설명해주세요 \*\*\*\*\*

세마포어는 공유 자원에 대한 접근을 제어하기 위해 사용되는 신호전달 메커니즘으로 공유 자원에 지정된 스레드 수만 접근할 수 있도록 관리합니다. 이미 허용된 최대 스레드 수에 도달해 임계영역에 진입하지 못할 경우 자발적으로 대기 상태에 들어가고, 임계 영역을 빠져나오는 스레드가 대기 상태의 스레드를 실행 대기 상태로 깨워주는 방식으로 동기화를 구현합니다.

자바에서는 세마포어 클래스가 제공되므로 직접 세마포어를 구현할 필요가 없으며 허용 스레드 수를 런타임에 동적으로 변경하면서 공유 자원을 관리할 수 있습니다.

### 뮤텍스(Mutex)와 세마포어(Semapphore)의 차이에 대해 설명해주세요

뮤텍스와 세마포어 모두 공유 자원에 대한 접근을 제어하는 방법으로 뮤텍스는 소유권이 있어서 단 하나의 스레드만 락을 얻어 임계영역에 접근하고 락을 보유한 스레드만이 락을 해제할 수 있는 반면, 세마포어는 지정된 수의 스레드가 임계 영역에 접근할 수 있으며 소유권이 없어서 세마포어를 사용하는 스레드 모두가 세마포어를 해제할 수 있습니다.

뮤텍스는 상호 배제를 위해 사용되며 하나의 스레드만 접근하도록 보장해야 하는 경우에 사용하고 세마포어는 리소스의 한정적인 사용을 제어하는 데 사용됩니다.

### 모니터에 대해 설명해주세요 \*\*\*\*\*

모니터는 자바에서 제공되는 동기화 메커니즘으로 뮤텍스나 세마포어보다 더 고수준의 기법입니다. 자바의 모든 객체는 기본적으로 모니터를 가지고 있습니다. JVM은 여러 스레드가 객체의 임계 영역에 진입하려 할 때 이 모니터를 사용해 스레드 간 동기화를 제공합니다.

모니터는 두 가지 주요 기능을 제공하는데 첫 번째는 상호 배제입니다. 객체의 모니터 락을 통해 여러 스레드가 동시에 공유 자원에 접근하지 못하도록 합니다. 자바에서는 synchronized 키워드를 공유 자원 블럭에 적용해 해당 객체의 모니터를 획득해야지만 공유 자원에 접근할 수 있도록 합니다. 이 synchronized 블록을 벗어나면 모니터 락이 해제되고, 대기 중인 다른 스레드가 락을 획득해 임계 영역으로 진입합니다.

두 번째 기능은 Cooperation(협력)입니다. 협력은 모니터의 조건 변수를 통해 스레드 간의 협력을 관리해 데이터의 일관성을 보장합니다. 자바의 조건 변수는 Object의 메서드들로 제공되는데요. 먼저 특정 조건이 만족할 때까지 대기 상태가 되는 wait(), 대기 중인 스레드들을 깨워 실행하도록 만드는 notify(), notifyAll()이 제공됩니다. 이를 통해 스레드 간의 wait와 notify를 조절해 race condition을 방지할 수 있습니다.

### 스핀락에 대해서 설명해주세요 \*\*\*\*\*

스핀락은 스레드가 임계영역을 사용할 수 있을 때까지 계속 반복해서 검사하는 동기화 기법입니다. 뮤텍스와 세마포어와 같은 블로킹 기반의 동기화 기법과는 달리 스레드가 공유 자원을 얻을 때까지 블로킹하지 않고 반복적으로 시도하기 때문에 컨텍스트 스위칭 비용이 감소하고, 공유 자원의 접근이 빠릅니다.

하지만 무한 루프로 인한 CPU 리소스 낭비가 있을 수 있고, 공유 자원에 대한 경쟁이 많은 경우, 또는 대기 시간이 긴 경우에는 비효율적이기 때문에 적절히 사용해야 합니다. 대부분의 경우는 스핀락보다는 뮤텍스나 세마포어같은 블로킹 기반의 동기화 기법을 사용하는 것이 나을 수 있습니다.

### 자바의 volatile의 원리에 대해 설명해주세요 \*\*\*\*\*

멀티스레딩 환경에서는 여러 스레드가 동시에 변수에 접근하고 수정할 수 있기 때문에 모든 스레드에게 공유 변수의 값이 일관되게 보여지도록 가시성이 보장되어야 하는데요. 캐시 메모리 현상으로 공유 변수에 대해 스레드간 가시성 문제가 발생할 경우 이 volatile 키워드를 사용해 가시성 문제를 해결할 수 있습니다.

volatile이 적용된 공유 변수는 CPU가 데이터 작업을 할 때 메인 메모리에서 공유 변수를 직접 읽고 수정된 결과를 메모리에 즉시 반영해 가시성 문제를 해결합니다.

다만 동시에 여러 스레드들이 공유 변수에 대해 읽기/쓰기를 실행할 경우 상호 배제를 보장해주진 않기 때문에 이때는 가시성과 상호 배제 모두 보장해주는 synchronized 키워드를 사용해야 합니다.

### 동기와 비동기의 차이에 대해 설명해주세요

동기 방식은 작업이 순차적으로 실행되는 방식으로, 하나의 작업이 완료될 때까지 다음 작업이 대기하는 구조입니다. 즉, 실행 중인 작업이 완료되어야만 다음 작업이 진행됩니다. 이로 인해 작업이 완료될 때까지 실행 흐름이 멈추고 대기해야 하는 블로킹 작업이 발생합니다.

반면에 비동기는 하나의 작업이 시작된 후에도 다음 작업이 병렬적으로 바로 실행될 수 있으며 작업의 결과에 관심이 없어서 기다리지 않고 다른 작업을 처리할 수 있기 때문에 논블로킹 작업이 가능합니다.

파일 읽기 작업을 예시로 비교해보자면 동기는 파일을 읽는 작업이 완료될때까지 다른 작업들이 대기하고, 비동기는 파일 읽기 작업의 완료를 기다리지 않고 그 동안 다른 작업을 수행합니다.

### 선점형 스케줄링과 비선점형 스케줄링의 차이를 설명해주세요

선점형 스케줄링은 운영체제가 실행중인 작업을 중간에 멈추고 다른 작업으로 교체할 수 있는 방식입니다. 즉, 현재 실행중인 작업이 끝나지 않더라도 더 높은 우선순위의 작업이 도착하면 현재 작업을 멈추고 새로운 작업을 실행할 수 있기 때문에 중요한 작업을 빠르게 처리할 수 있습니다. 대표적으로 Round Robin, SRF 알고리즘이 있습니다.

비선점형 스케줄링은 한번 CPU를 점유하면 해당 작업이 완료될까지가 다른 작업으로 교체되지 않는 방식입니다. 작업의 예측 가능성이 높지만 중요한 작업이 늦게 도착하면 오랜 시간 대기해야 하는 단점이 있습니다. 대표적으로 FCFS(First-Come, First-Served)와 SJF(Shortest Job First) 알고리즘이 있습니다.

### 콘보이 현상(convoy effect)이란 무엇이고, 콘보이 현상이 발생될 수 있는 CPU 스케줄러 알고리즘은 무엇인지 설명해주세요

콘보이 현상은 하나의 긴 작업이 여러 짧은 작업들의 진행을 지연시키는 현상으로 긴 작업이 CPU를 독점해서 뒤따르는 짧은 작업들이 오랜 시간 대기하게 되는 문제를 발생시킵니다. 이로 인해 작업이 공정하게 처리되지 않게 되고, 성능 또한 저하됩니다.

콘보이 현상은 주로 작업의 길이에 상관없이 도착한 순서대로 작업을 처리하는 FIFO 스케줄링 알고리즘에서 발생할 수 있습니다.

### 콘보이 현상을 방지하기 위한 방법을 설명해주세요 \*\*\*\*\*

콘보이 현상을 방지하기 위한 대표적인 방법 3가지 정도가 있습니다.

첫째로, Shortes Job Next(SJN) 또는 Shortest Job First(SJF) 스케줄링입니다. 실행 시간이 가장 짧은 작업을 먼저 처리해서 긴 작업이 짧은 작업들의 진행을 방해하는 것을 방지합니다. 평균 대기 시간을 최소화할 수 있지만 실행 시간을 예측하기 어렵습니다.

두번째로, Round Robin (RR) 스케줄링입니다. 각 작업에 동일한 시간 할당량을 주고, 시간이 끝나면 다음 작업으로 넘어가는 방식으로 모든 작업이 공평하게 CPU 시간을 사용할 수 있도록 하기 때문에 가장 공정하고 응답성을 보장할 수 있습니다.

세번째로, Priority Scheduling with Aging 입니다. 이 방법은 우선순위 기반 스케줄링에서 낮은 우선순위의 작업이 오랫동안 대기하면 우선순위를 점진적으로 높여주는 방법으로 낮은 우선순위 작업이 무한정 대기하는 것을 방지할 수 있습니다.

### 페이지 교체 알고리즘에 대해 설명해주세요
