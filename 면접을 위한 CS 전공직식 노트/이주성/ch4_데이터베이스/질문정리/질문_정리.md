## 데이터베이스

### 데이터베이스의 특징에 대해 설명해주세요

데이터베이스는 질의에 대한 응답이 실시간으로 처리되어야 하며, 동적으로 변화하는 데이터를 반영해 최신의 데이터를 유지해야 합니다. 또한, 다수의 사용자가 동시에 같은 내용의 데이터를 이용할 수 있어야 하고, 데이터 참조 시 레코드의 주소가 아닌 사용자가 요구하는 데이터 내용으로 찾을 수 있습니다.

### 데이터베이스 언어(DDL, DML, DCL)에 대해 설명해주세요

DDL은 create, drop 같이 데이터베이스 구조를 정의, 수정 삭제하는 언어이고 ,DML은 select, update와 같이 데이터베이스 내의 데이터를 조작하는 언어입니다. DCL은 commit, rollback과 같이 데이터에 대한 무결성 유지, 병행 수행 제어 등을 관리하는 언어입니다.

### SELECT 쿼리의 수행 순서를 알려주세요.

테이블을 지정하는 *FROM*이 가장 먼저 수행되고, *JOIN*과 조건 *ON*이 실행된 후 *WHERE, GROUP BY, HAVING* 과 같은 조건, 집계 관련 명령어가 실행된 뒤에 SELECT로 최종 조회 결과를 선택합니다.

그 이후에 DISTINCT로 중복을 제거하고, ORDER BY로 정렬한 뒤 LIMIT로 반환할 행의 수를 제한합니다.

### 트리거(Trigger)에 대해 설명해주세요

트리거는 특정 테이블에 대한 이벤트에 반응해 INSERT, UPDATE 같은 DML 문이 수행되었을 때 데이터베이스에서 자동으로 동작하도록 작성된 프로그램입니다.

쇼핑몰 사이트를 예시로 생각해보면 고객이 주문을 완료했을 때 데이터베이스에 트리거를 설정해두면 주문이 완료될 때마다 자동으로 재고를 줄이거나, 고객에게 알림을 보내느 작업을 실행할 수 있습니다.

### Index에 대해 설명해주시고, 장/단점에 대해 말해주세요

INDEX는 데이터베이스에서 데이터를 조회할 때 결과를 빨리 얻을 수 있도록 해주는 자료구조로, 지정한 컬럼들을 기준으로 메모리 영역에 일종의 목차를 생성하는 것입니다. 지정된 컬럼으로 조회 시 모든 데이터를 일일히 확인할 필요 없이 목차를 통해 빠르게 데이터를 찾아낼 수 있습니다.

하지만 인덱스는 기존 데이터베이스의 추가 공간을 사용하며 인덱스 생성 시에 시간이 걸려 insert, update, delete와 같은 데이터 변경 쿼리의 경우 성능이 더 떨어질 수 있습니다.

따라서 인덱스를 사용하되 최소한으로 사용하고 효율적으로 설계해 단점을 보완하도록 해야합니다.

### 그렇다면 DBMS는 Index를 어떻게 관리하고 있나요? (Index 자료구조)

인덱스를 관리하는 대표적인 자료구조는 B+Tree입니다. 부모 노드와 자식 노드가 연결된 트리구조에 리프 노드들을 LinkedList로 연결한 형태입니다. 덕분에 순차적으로 데이터를 검색하는게 빠르고, 범위 검색에도 강하고 안정적입니다.

또 다른 자료구조로는 해시 테이블이 있는데요. 컬럼의 값으로 해시 값을 만들어서 인덱스를 관리하는 방식입니다. O(1)의 매우 빠른 검색 속도가 장점이지만 범위 검색에는 사용하기 어렵다는 단점이 있습니다.

### 정규화에 대해 설명해주세요

하나의 릴레이션에 하나의 의미만 존재하도록 릴레이션을 분해하는 과정으로 데이터의 일관성을 유지하면서 중복을 최소화하고, 데이터 유연성을 높이는 것이 핵심입니다.

첫 번째 단계는 1차 정규화로 테이블의 모든 도메인이 더 이상 쪼갤 수 없는 원자 값으로만 구성되도록 합니다.

2차 정규화는 모든 속성이 기본키에 완전 함수 종속이 되도록 합니다. 즉, 어떤 속성이 기본키의 일부가 아닌 기본키 전체에 의존하도록 만들어야 합니다.

3차 정규화는 기본키에 종속되지 않은 다른 속성 간의 이행적 종속을 제거하는 과정입니다. 즉, 기본키를 통해 다른 속성 하나가 결정됐는데 그 속성으로 인해 또 다른 속성이 결정되는 상황을 없애고 독립적으로 만들어야 합니다.

이런식으로 정규화 과정을 거쳐나가면서 데이터베이스의 이상현상을 제거해 나갑니다.

### 정규화의 장단점에 대해 설명해주세요

정규화를 거치면 데이터의 일관성을 유지할 수 있고, 데이터베이스의 이상현상 문제를 해결할 수 있으며 데이터 구조 확장 시 구조 변경을 최소화할 수 있습니다.

하지만 릴레이션 분해로 인해 JOIN 연산이 많아질 수 밖에 없는데 질의에 대한 응답 시간이 느려질 수 있습니다. 또한 과도한 정규화로 인해 설계가 복잡해지면서 유지보수가 어려워질 수 있습니다.

따라서 정규화를 진행할 때 시스템의 성능 요구사항을 고려해서, 필요에 따라 정규화를 일부 포기할 필요도 있습니다.

### 이상 현상의 종류에 대해 설명해주세요

이상 현상은 잘못 설계된 테이블에 데이터를 삽입, 삭제, 수정할 때 생기는 오류를 말합니다.

자료를 삽입할 때 특정 속성에 해당하는 값이 없어 NULL을 입력해야 하는 삽입 이상 현상, 중복된 데이터 중 일부만 수정되어 데이터 모순이 일어나는 갱신 이상, 의도하지 않은 다른 정보까지 삭제되어버리는 삭제 이상이 있습니다.

이러한 이상 현상을 방지하기 위해 데이터 정규화 과정이 필요합니다.

### 역정규화를 하는 이유에 대해 설명해주세요

정규화를 거치면서 릴레이션의 분해로 인해 JOIN 연산이 많아져 성능이 저하될 수 있습니다. 읽기 작업이 많이 필요한 상황에서 성능 저하의 문제가 발생했을 때 DB의 성능을 향상시키기 위해 진행합니다.

### SQL Injection이 무엇인지 설명해주세요

SQL Injection이란 공격자가 악의적인 의도를 갖는 SQL 구문을 삽입하여 데이터베이스를 비정상적으로 조작하는 코드 인젝션 공격 기법입니다.

예를 들어 검색 창에 악의적으로 SQL으로 해석되도록 입력해서 데이터에 접근하는 경우가 있습니다.

### SQL Injection을 방어 및 방지하기 위한 방법에 대해 설명해주세요

첫 번째는 사용자가 입력한 값이 SQL 쿼리에 영향을 주지 않도록 입력값을 철저히 검증해야 합니다. 숫자만 들어와야 하는 곳에 문자열이 들어오지 않도록 하거나 특정 길이 이상의 값을 차단하는 식으로 검증합니다.

두 번째는 미리 정의된 SQL 쿼리를 저장 프로시저에 저장해두고 필요할 때마다 이 쿼리를 실행하도록 해서 쿼리의 구조가 변경되지 않도록 하는 방법이 있습니다.

### RDBMS와 NoSQL의 차이에 대해 설명해주세요

먼저 RDBMS는 관계형 데이터베이스로 데이터를 2차원 데이블 형태로 표현합니다. 각 테이블은 행과 열로 구성되며 테이블 간의 관계를 통해 복잡한 데이터 모델을 표현할 수 있습니다. SQL을 사용해 데이터를 조작하고 트랜잭션과 ACID 특성을 보장하며 데이터 무결성을 유지합니다.

반면 NoSQL은 Not Only SQL의 약자로 비관계형 데이터베이스를 뜻하빈다. 유연한 스키마를 가지고 있어 구조화되지 않은 대용량 데이터를 처리하는 데 적합합니다. 키-값, 문서, 컬럼 기반, 그래프 등 다양한 데이터 모델을 제공하며, 수평적 확장성이 뛰어나 대규모 분산 시스템에 적합합니다.

### RDBMS와 NoSQL은 어느 경우에 적합한가요?

RDBMS는 금융 시스템처럼 데이터 구조가 명확하고 데이터 일관성과 정확성이 중요한 도메인에서 주로 사용됩니다. 중복되는 데이터가 없다는 장점 때문에 변경이 용이해서 관계를 맺고 있는 데이터가 자주 변경되는 시스템에 적합합니다. 또한 복잡한 조인 연산과 트랜잭션 처리가 필요한 경우에도 사용하기 좋습니다.

NoSQL은 정확한 데이터 구조를 알 수 없고 데이터가 변경/확장될 수 있는 경우 사용합니다. 유연한 스키마를 가지고 있어 데이터 모델을 자유롭게 변경할 수 있다는 점입니다. 또한, 수평적 확장(Scale-out)이 용이해 대규모 분산 시스템에서 효과적입니다. 따라서 실시간 빅데이터 처리, 소셜 네트워크, IoT 데이터 수집 등 대용량 데이터의 빠른 처리가 필요한 시스템에 적합합니다. 다만, 데이터 중복이 발생될 수 있어 데이터 수정이 빈번한 시스템에는 적합하지 않습니다.

### 트랜잭션이란 무엇인지 설명해주세요

데이터베이스의 상태를 변화시키는 하나의 논리적 작업 단위를 말합니다. 예를 들어, 은행에서 계좌 이체를 할 때, 한 계좌에서 돈을 빼고 다른 계좌에 그 돈을 넣는 과정 전체가 하나의 트랜잭션이 됩니다.

트랜잭션은 데이터의 무결성을 유지하고 데이터의 일관된 상태를 유지하기 위해 여러 작업을 하나로 묶어 처리합니다. 따라서 모든 작업이 성공적으로 완료되면 commit하고, 하나라도 실패하면 모든 작업을 취소하고 rollback합니다.

### 트랜잭션의 특성(ACID)에 대해 설명해주세요

트랜잭션은 4가지 특성이 있는데요.

트랜잭션의 모든 연산은 전부 성공하거나 전부 실패해야 하는 Atomicity(원자성), 트랜잭션이 성공적으로 완료되면 언제나 일관성 있는 데이터 베이스 상태를 유지하는 Consistency(일관성), 둘 이상의 트랜잭션이 병렬로 실행되고 있을 때 서로 관여할 수 없는 Isolation(독립성), 트랜잭션이 성공적으로 완료되면 그 결과는 영구적으로 반영되어야 하는 Durability(지속성)이 있습니다.

### DB 락에 대해 설명해주세요

데이터베이스 락은 트랜잭션의 동시성을 제어하고 데이터의 일관성을 유지하며, 트랜잭션의 순차성을 보장합니다.

Read Lock이라고 불리는 공유락은 데이터를 읽을 때 사용하는 락으로 데이터 조회만 수행하므로 데이터의 일관성을 해치지 않습니다. 따라서 여러 트랜잭션이 동시에 같은 데이터에 대한 공유락을 획득할 수 있습니다.

Write Lock이라고 불리는 배타락은 데이터를 변경할 때 사용되는 락으로 트랜잭션이 commit 혹은 rollback될 때까지 유지됩니다. 하나의 트랜잭션만 배타락을 획득할 수 있으며, 다른 트랜잭션의 접근을 차단합니다.

낙관적 락은 대부분의 트랜잭션에서 충돌이 발생하지 않을 것이라고 낙관적으로 바라보는 관점으로 데이터베이스가 제공하는 락 기능을 사용하지 않고 엔티티의 버전을 통해 어플리케이션 레벨에서 동시성을 제어하는 방법입니다.

비관적 락은 대부분의 트랜잭션에서 충돌이 발생할 것이라고 비관적으로 바라보는 관점으로 우선 데이터베이스 트랜잭션 락을 걸고 보는 방법입니다. 트랜잭션에서 데이터를 읽을 때부터 락을 걸고 커밋이 완료될때까지 락을 유지해 다른 트랜잭션에서 해당 데이터를 읽거나 수정하지 못하도록 하는 방법입니다. 충돌이 자주 발생할 것 같은 상황에서 사용하기 좋습니다.

### Elastic Search의 키워드 검색과 RDBMS의 LIKE 검색의 차이에 대해 설명해주세요.

RDBMS의 LIKE 검색은 주로 단순한 문자열 매칭에 사용되는 방법입니다. 매우 간단하지만 정확한 철자 매칭만 가능해서 유사어나 오타에 대응하기 어렵고, 대량의 데이터에서 성능이 저하되는 단점이 있습니다. 특히 와일드카드를 사용할 경우 인덱스를 효과적으로 활용하지 못해서 전체 테이블을 풀 스캔 해야할 수도 있습니다.

반면 Elastic Search는 역인덱스 구조를 사용해 대량의 데이터에서 빠른 검색을 지원합니다. 또한 동의어나 유사어 검색, 오타가 난 단어도 찾아낼 수 있는 퍼지 검색 등 다양한 검색 기법을 지원합니다. 또한 비정형 데이터의 색인과 검색도 가능하고, 분산 시스템을 기반으로 하고 있어 쉽게 확장할 수 있다는 장점이 있습니다. 그러나 설정과 운영이 복잡하고 실시간 트랜잭션 처리나 데이터의 일관성 면에서는 RDBMS가 나을 수 있습니다.

### 옵티마이저(Optimizer)에 대해 설명해주세요

옵티마이저는 DBMS 내부의 핵심 엔진으로 SQL 쿼리를 가장 효율적으로 실행할 수 있는 최적의 실행 계획을 세웁니다. 이 때 먼저 SQL문을 분석해 테이블 접근 순서, 조인 방법, 인덱스 사용 여부 등을 고려해 여러 실행 가능한 계획을 생성한 뒤에 I/O 비용, CPU 및 메모리 사용량을 고려해 비용이 가장 적게 드는 최적의 계획을 선택합니다. 선택된 실행 계획을 바탕으로 실제 쿼리 실행을 위한 세부 지침을 만듭니다.

하지만 옵티마이저가 항상 완벽한 계획을 세우는 것은 아니기 때문에 SQL 튜닝이 필요할 수 있습니다.

### DB 튜닝(Tunning)이 무엇인지 그리고 튜닝의 3단계에 대해 설명해주세요

DB 튜닝은 데이터베이스 시스템의 전반적인 성능을 개선하는 과정으로 총 3단계로 나눌 수 있습니다.

첫 번째는 DB 설계 튜닝입니다. DB를 설계하는 초기 단계에서 효율적인 데이터 모델링, 적절한 인덱스 설계 등을 고려해 필요에 따라 반정규화를 수행하거나 데이터를 물리적으로 분산 배치하는 등의 방법이 있습니다.

두 번째는 DBMS 튜닝입니다. 데이터베이스 관리 시스템의 환경 설정을 최적화하는 방법으로 메모리, CPU, I/O 등의 시스템 자원의 효율적인 사용에 초점을 맞춥니다. 예를 들면 버퍼나 캐시 크기를 조정해 메모리 사용을 최적화하거나 병렬 처리 옵션을 조정해 CPU 사용을 개선하는 방법이 있습니다.

세 번째는 SQL 튜닝입니다. 애플리케이션 관점에서 실제 실행되는 SQL 쿼리의 성능을 개선하는 방법입니다. 효율적인 조인 방식 선택, 적절한 인덱스 사용, 실행 계획 분석 등의 방법이 있습니다.

### inner join과 outer join의 차이를 설명해주세요.

이너 조인은 두 테이블 간의 조인 조건을 만족하는 행만을 결과 집합에 포함시키는 방법으로 양쪽 테이블의 일치하는 데이터만 결과로 반환됩니다. 예를 들어 주문 테이블과 고객 테이블을 이너 조인할 때 주문이 있는 고객의 정보만 결과로 얻습니다.

아우터 조인은 한 쪽 테이블의 모든 레코드와 다른 쪽 테이블의 일치하는 레코드를 반환하는 방법으로 일치하는 행이 없는 경우에도 기준 테이블의 행은 결과에 포함되며 그 필드는 NULL로 채워집니다. 종류로는 왼쪽행 기준인 Left, 오른쪽 행 기준인 Right, 양쪽 테이블 기준인 Full이 있습니다.주문 테이블과 고객 테이블을 고객 테이블 기준으로 아우터 조인을 하면 주문하지 않은 고객도 결과에 포함되어 반환됩니다.

### group by의 역할에 대해 설명해주세요.

group by는 데이터를 특정 컬럼을 기준으로 그룹화해서 COUNT, SUM, AVG, MAX, MIN 등의 집계 함수를 통해 집계 연산을 수행할 때 사용됩니다. 대량의 데이터를 의미 있는 정보로 요약할 때 사용할 수 있고, 여러 컬럼을 기준으로 그룹화할 수 있어서 더 세분화된 분석이 가능합니다.

데이터 분석에 매우 유용하지만 대양의 데이터를 다룰 때에는 성능에 영향이 가므로 인덱스 설계나 쿼리 최적화 등을 고려해야 합니다.

### DELETE, TRUNCATE, DROP의 차이를 설명해주세요

DELETE는 테이블에서 특정 조건에 맞는 원하는 데이터를 삭제합니다. 트랜잭션 로그에 기록되므로 롤백이 가능하며 행 단위로 삭제하기 때문에 대량의 데이터를 삭제할 때에는 느릴 수 있습니다. 또한 테이블 구조는 그대로 유지되며 AUTO_INCREMENT 값은 초기화되지 않습니다.

TRUNCATE는 테이블 구조를 재설정하는 방식으로 테이블의 모든 데이터를 빠르게 삭제합니다. 따라서 테이블 구조는 유지되지만 AUTO_INCREMENT 값이 초기화되며 인덱스가 삭제됩니다. 롤백이 불가능하고, DDL로 분류되어 암시적 커밋이 발생합니다.

DROP은 테이블 자체를 데이터베이스에서 완전히 제거하는 명령어로 모든 데이터, 인덱스, 제약 조건 등 관련된 모든 것이 삭제됩니다. 롤백이 불가능하며 DDL 명령어로 실행 즉시 커밋됩니다.

### 데이터베이스 클러스터링과 리플리케이션의 차이에 대해 설명해주세요

클러스터링은 여러 서버를 하나의 시스템처럼 작동하게 하는 기술로 주로 고가용성과 로드 밸런싱을 위해 사용됩니다. 모든 노드가 활성 상태로 동작하며 요청을 분산 처리해서 시스템 전체의 성능을 향상시키고 하나의 DB가 죽어도 다른 DB가 살아 있어 장애를 대비할 수 있습니다. 하지만 비용이 많이 들고, 병목 현상이 발생할 수 있습니다.

반면 리플리케이션은 데이터를 여러 노드에 복제하는 기술로 주로 데이터 안정성과 읽기 성능 향상을 위해 사용되며, 마스터-슬레이브 구조로 작동합니다. 마스터에서 변경된 데이터가 슬레이브로 복제되어 데이터 백업, 읽기 성능 향상, 지연 시간 감소 등의 효과를 제공합니다. 하지만 노드들 간 동기화가 보장되지 않아 데이터의 일관성이 떨어질 수 있으며 마스터 DB가 다운될 경우 복구가 어렵습니다.

클러스터링이 주로 성능과 가용성에 초점을 맞춘다면 리블리케이션은 데이터의 안정성과 읽기 성능에 초점을 맞춥니다. DB 요청의 대부분이 읽기 작업이기 때문에 리플리케이션만으로 충분히 성능을 높일 수 있습니다.

### HAVING과 WHERE의 차이를 설명해주세요

둘 다 데이터 필터링에 사용되지만 목적과 적용 시점이 다릅니다.

WHERE 절은 개별 행에 대한 필터링으로 GROUP BY절 이전에 적용되며 집계 함수를 사용할 수 없습니다. 주로 테이블에서 특정 조건을 만족하는 행을 선택할 때 사용합니다.

HAVING절은 그룹화된 결과에 대한 필터링으로 GROUP BY절 이후에 적용되며 집계 함수를 사용할 수 있습니다. 주로 그룹화된 데이터에 대한 조건을 지정하는데 사용합니다.

예를 들어 급여가 3000 이상인 직원을 찾을 때에는 WHERE를 사용하고, 부서별 평균 급여가 5000 이상인 부서를 찾을 때에는 HAVING을 사용합니다.

### JOIN에서 ON과 WHERE의 차이를 설명해주세요

ON은 두 테이블을 어떤 기준으로 조인할지 조건을 지정하는 명령어로  JOIN이 수행되는 시점에 적용됩니다. WHERE은 JOIN이 완료된 이후에 그 결과 대한 필터링을 수행합니다.

